\documentclass[a4paper,12pt]{article} % Puedes cambiar 'article' por otro tipo de documento

\usepackage[left=2cm, right=2cm, top=3cm, bottom=3cm]{geometry} %Para poner los márgenes

\usepackage{float} %Para hacer que la megatabla no se vaya volando a la última página y forzar que se quede usando [H]

% Idioma español y codificación
\usepackage[spanish]{babel} % Traduce palabras como "Contenido", "Capítulo", etc.
\usepackage[utf8]{inputenc} % Permite escribir caracteres en español (á, é, ñ, etc.)
\usepackage[T1]{fontenc}    % Mejora la salida de caracteres acentuados en PDF

% Paquetes matemáticos
\usepackage{amsmath}  % Permite usar comandos avanzados de matemáticas
\usepackage{amssymb}  % Agrega símbolos matemáticos adicionales
\usepackage{amsthm}   % Permite definir teoremas, lemas, etc.
\usepackage{mathrsfs} % Fuente adicional para letras matemáticas

% Para mejor tipografía en matemáticas
\usepackage{mathtools}

% Si necesitas gráficos
\usepackage{graphicx} 

% Si usas referencias cruzadas en el documento
\usepackage[hidelinks]{hyperref}  % Enlaces clicables en PDF

%Para poner el color de los enlaces azul
\hypersetup{
    colorlinks=true,       % Habilita los enlaces de colores
    linkcolor=black,        % Color de los enlaces internos (por ejemplo, referencias a secciones)
    urlcolor=magenta,      % Color de los enlaces a direcciones web
    citecolor=red,         % Color de las referencias bibliográficas
    filecolor=cyan,        % Color de los enlaces a archivos
}

\renewcommand{\contentsname}{Índice} % Cambia "Contenido" por "Índice"

\usepackage{listings}
\usepackage{xcolor} % Para definir colores, opcional

% Configuración básica de listings:
\lstset{
    language=C,                    % Especifica el lenguaje (puede ser Python, Java, etc.)
    basicstyle=\ttfamily\small,     % Fuente de tipo monoespaciada
    numbers=left,                  % Números de línea a la izquierda
    numberstyle=\tiny,             % Estilo de los números de línea
    stepnumber=1,                  % Mostrar número en cada línea
    numbersep=10pt,                % Espacio entre número y código
    backgroundcolor=\color{lightgray}, % Color de fondo
    showspaces=false,              % No resaltar espacios
    showstringspaces=false,        % No resaltar espacios en cadenas
    showtabs=false,                % No resaltar tabulaciones
    frame=single,                  % Agregar un marco alrededor del código
    rulecolor=\color{black},       % Color del marco
    captionpos=b,                  % Posición de la leyenda (b de bottom)
    breaklines=true,               % Saltos automáticos de línea
    breakatwhitespace=false,
    title=\lstname,                % Muestra el nombre del archivo, si se especifica
    keywordstyle=\color{blue},     % Color de las palabras clave
    commentstyle=\color{green},    % Color de los comentarios
    stringstyle=\color{red}        % Color de las cadenas
}

\usepackage{caption}
\captionsetup[table]{labelformat=empty} %Para que no salgan numeradas las tablas
\captionsetup[lstlisting]{labelformat=empty} %Para que no salgan numeradas los fragmentos de código

\setlength{\parindent}{0,75cm} %Para que la sangría no sea tan grande


\begin{document}
\begin{titlepage}
	\centering

	\includegraphics[width=0.3\textwidth]{logo_ugr.png} % Ajusta el tamaño según necesites (0.3\textwidth es solo un ejemplo)
	\vspace{1cm} % Ajusta el espacio según lo necesites

	{\bfseries\LARGE Universidad de Granada \par}
	\vspace{1cm}
	{\scshape\Large Facultad de Ingeniería Informática y telecomunicaciones \par}
	\vspace{3cm}
	{\scshape\Huge Práctica 1: Eficiencia de algoritmos \par}
	\vspace{3cm}
	{\itshape\Large Doble Grado Ingeniería Informática y Matemáticas \par}
	\vfill
	{\Large Autores: \par}
	{\Large Adolfo Martínez Olmedo, Pablo Delgado Galera, Marcos Baena Solar \par}
	\vfill
	{\Large Marzo 2025 \par}
\end{titlepage}

\tableofcontents
\newpage


% Sections
\section{Introducción}
Comenzemos estableciendo las características de cada uno de nuetros
ordenadores, ya que tienen prestaciones diferentes

\begin{table}[h!]
	\centering
	\makebox[\textwidth]{%
		\scalebox{0.6}{%
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				\textbf{}       & \textbf{CPU}                         & \textbf{RAM} & \textbf{Caché L1d}    & \textbf{Caché L1i}    & \textbf{Caché L2}    & \textbf{Caché L3}   & \textbf{SO}        \\ \hline
				Adolfo Martínez & AMD Ryzen 7 4800HS                   & 16GB         & 256 KiB               & 256 KiB               & 4 MiB                & 8 MiB               & Ubuntu 22.04.4     \\ \hline
				Marcos Baena    & AMD 3020e with Radeon Graphics       & 5,7Gi        & 64 KiB (2 instances)  & 128 KiB (2 instances) & 1 MiB (2 instances)  & 4 MiB (1 instance)  & Ubuntu 24.04.1 LTS \\ \hline
				Pablo Delgado   & 11th Gen Intel(R) Core(TM) i7-11800H & 15 Gi        & 384 KiB (8 instances) & 256 KiB (8 instances) & 10 MiB (8 instances) & 24 MiB (1 instance) & Ubuntu 24.04.1     \\ \hline
			\end{tabular}
		}
	}
	\caption{Características de los ordenadores}
	\label{tab:caracteristicas}
\end{table}

En esta práctica vamos a discutir la eficiencia de los algoritmos
desde tres puntos de vista distintos:

\begin{itemize}
	\item \textbf{Punto 1:} Descripción del primer punto.
	\item \textbf{Punto 2:} Descripción del segundo punto.
	\item \textbf{Punto 3:} Descripción del tercer punto.
\end{itemize}

\subsection{Análisis de la eficiencia teórica}
En el análisis de la eficiencia teórica estudiaremos el tiempo de ejecución del algoritmo
mediante funciones en notación \textit{Big-O}, que representarán el peor caso posible.
En este análisis, no usaremos medidas reales de computación, sino que calcularemos funciones
mediante técnicas vistas en Estructuras de Datos y Algorítmica.
\subsection{Análisis de la eficiencia empírica}
Para el análisis de la eficiencia empírica ejecutaremos los algoritmos implementados en C++ en cada
una de nuestras máquinas y mediermos el tiempo de ejecución mediante la
clase <chrono>. Cada miembro del equipo ejecutará cada algoritmo 10 veces con todos los tamaños especificados,
para luego hacer una media y obtener resultados más fiables.
\subsection{Análisis de la eficiencia híbrida}
En el análisis de la eficiencia hibrída, tomammos los resultados de los integrantes del grupo y hallamos
la constante $\kappa$. En la representación de los resultados usaremos la herramienta gnuplot.

Para poder completar esta parte del estudio de la eficiencia usaremos los resultados del análisis teórico, para
poder conocer la forma de la función a la que queremos ajustar los datos. Por ejemplo para representar en gnuplot $O(n^{3})$:

\begin{lstlisting}[language=C, caption={Ejemplo de $O(n^{2})$}]
       gnuplot> f(x) = a0*x*x+a1*x+a2
        \end{lstlisting}

Después de esto debemos hacer la regresión usando el método de mínimos, cuyo funcionamiento conoces gracias a la asignatura EDIP:

\begin{lstlisting}[language=C, caption={Uso de gnuplot para la regresión}]
        gnuplot> fit f(x) 'result.dat' via a0,a1,a2
         \end{lstlisting}

En este caso result.dat es nuestro fichero de datos.
Nos centraremos en \textit{Final set of Parameters}, que nos muestra los coeficientes de la fórmula de regresión
junto con la bondad del ajuste realizado.

Finalmente, hacemos el plot de los puntos y la curva de ajuste para ver como de buena es el cálculo de la eficiencia híbrida. Usaremos el
siguiente comando:

\begin{lstlisting}[language=C, caption={Representación de la regresión}]
        gnuplot> plot 'result.dat', f(x) title 'Curva de ajuste'
         \end{lstlisting}




\section{Desarrollo}
Una vez que hemos discutido las maneras de estudiar la eficiencia, veamos los problemas
que vamos a analizar: La \textbf{Ordenación de vectores},
los \textbf{Números de Catalan}, y las \textbf{Torres de Hanoi.}

\subsection{Ordenación de vectores}
\subsubsection{QuickSort}
\paragraph{Eficiencia teórica (caso promedio)}

A continuación se presenta el código que hemos usado para hacer el análisis:

\begin{lstlisting}[language=C++, caption={Código de QuickSort}]
int partition(vector<int> &vec, int low, int high) {
	int pivot = vec[high];
	int i = low - 1;

	for (int j = low; j < high; j++) {
		if (vec[j] <= pivot) {
			i++;
			swap(vec[i], vec[j]);
		}
	}
	swap(vec[i + 1], vec[high]);
	return i + 1;
}

void QuickSort(vector<int> &vec, int low, int high) {
	if (low < high) {
		int pi = partition(vec, low, high);
		QuickSort(vec, low, pi - 1);
		QuickSort(vec, pi + 1, high);
	}
}
\end{lstlisting}


Tras analizar el código hemos llegado a la siguiente fórmula de recurrencia:

\begin{equation*}
	T(n) = 2\cdot T(n/2) + n
\end{equation*}

Concluimos que en las dos llamadas recursivas de QuickSort
se utiliza \textit{pi} que es el resultado de hacer la partición por la mitad del vector. En cuanto
al término independiente este se corresponde al bucle de la función auxiliar \textit{partition}, que en
el peor de los casos recorre el vector totalmente.

Procedemos a resolver la fórmula de recurrencia utilizando el cambio de variable $n=2^h$:

\begin{equation*}
	T(2^{h}) - 2\cdot T(2^{h-1}) = 2^{h}
\end{equation*}

El resultado de la parte homogénea es el siguiente:

\begin{align*}
	x - 2 = 0 \\
	x = 2
\end{align*}

El resultado de la parte independiente es:

\begin{align*}
	p(h) = 1 \\
	b = 2    \\
	d = 0    \\
\end{align*}

Por tanto la solución es $(x-2)^2$, con multiplicidad 2,y deshaciendo el
cambio de variable y expresando la ecuación con coeficientes llegamos finalmente
a:

\begin{equation*}
	c_{1}\cdot 2^{\log _{2}(n)} + c_{2}\cdot \log_{2}(n)\cdot 2^{\log_{2}(n)}
\end{equation*}

De donde se deduce que QuickSort tiene una eficiencia de $O(n\cdot \log(n))$
\\ 
\paragraph{Eficiencia práctica (caso promedio)}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 1.000 hasta 1.000.000 con saltos de 25.000:

\paragraph{Eficiencia teórica (peor caso)}


\paragraph{Eficiencia práctica (peor caso)}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 1.000 hasta 1.000.000 con saltos de 25.000:

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{%
	\begin{tabular}{|c|c|c|c|}
	\hline
	\textbf{Tam.caso} & \textbf{Tiempo (us)} & \textbf{$K=$ Tiempo/$f(n)$} & \textbf{Tiempo teórico estimado = $K\cdot f(n)$} \\
	\hline
	1000   & 135    & 0,000135    & 4,081703271  \\
	26000  & 3923   & 5,80325E-06 & 2759,231411  \\
	51000  & 7972   & 3,06498E-06 & 10616,51021  \\
	76000  & 12281  & 2,12621E-06 & 23575,9181   \\
	101000 & 16285  & 1,59641E-06 & 41637,45507  \\
	126000 & 21136  & 1,33132E-06 & 64801,12114  \\
	151000 & 25810  & 1,13197E-06 & 93066,91629  \\
	176000 & 30765  & 9,93188E-07 & 126434,8405  \\
	201000 & 34579  & 8,55895E-07 & 164904,8939  \\
	226000 & 39644  & 7,76177E-07 & 208477,0763  \\
	251000 & 44586  & 7,07703E-07 & 257151,3878  \\
	276000 & 48868  & 6,41514E-07 & 310927,8284  \\
	301000 & 53481  & 5,90291E-07 & 369806,3981  \\
	326000 & 58561  & 5,51028E-07 & 433787,0969  \\
	351000 & 63962  & 5,19168E-07 & 502869,9247  \\
	376000 & 69415  & 4,90996E-07 & 577054,8817  \\
	401000 & 73753  & 4,5866E-07  & 656341,9677  \\
	426000 & 78161  & 4,30696E-07 & 740731,1829  \\
	451000 & 83203  & 4,09059E-07 & 830222,5271  \\
	476000 & 89583  & 3,95377E-07 & 924816,0004  \\
	501000 & 93698  & 3,73297E-07 & 1024511,603  \\
	526000 & 98931  & 3,5757E-07  & 1129309,334  \\
	551000 & 104380 & 3,43807E-07 & 1239209,195  \\
	576000 & 109009 & 3,28562E-07 & 1354211,185  \\
	601000 & 113194 & 3,13382E-07 & 1474315,303  \\
	626000 & 118932 & 3,03494E-07 & 1599521,551  \\
	651000 & 123600 & 2,91646E-07 & 1729829,928  \\
	676000 & 127280 & 2,78527E-07 & 1865240,434  \\
	701000 & 134006 & 2,72702E-07 & 2005753,069  \\
	726000 & 138300 & 2,62391E-07 & 2151367,833  \\
	751000 & 146089 & 2,59023E-07 & 2302084,727  \\
	776000 & 147986 & 2,45752E-07 & 2457903,749  \\
	801000 & 156995 & 2,44693E-07 & 2618824,901  \\
	826000 & 158179 & 2,3184E-07  & 2784848,181  \\
	851000 & 165306 & 2,2826E-07  & 2955973,591  \\
	876000 & 173671 & 2,26318E-07 & 3132201,13   \\
	901000 & 176034 & 2,16844E-07 & 3313530,797  \\
	926000 & 180388 & 2,10371E-07 & 3499962,594  \\
	951000 & 186721 & 2,06458E-07 & 3691496,52   \\
	976000 & 189852 & 1,99304E-07 & 3888132,575  \\
	\hline
	\end{tabular}%
	}
	\caption{Resultados de tiempos y estimaciones}
	\label{tab:resultados}
	\end{table}

	Los resultados de graficar los resultados haciendo la curva de ajuste con \textit{f(x) = $x^{2}$} son:
	\begin{figure}[ht]
		\centering
		\includegraphics[width=\linewidth]{graficaquicksortpeorcaso.jpeg}
		\caption{Ajuste por regresión de \textit{QuickSort}}
	  \end{figure}
	  
\subsection{Los números de Catalan}

\subsubsection{Versión recursiva}

\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\subsubsection{Versión iterativa (programación dinámica)}
\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\subsubsection{Versión iterativa directa usado el coeficiente binomial}
\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\subsection{Las Torres de Hanoi}

\subsubsection{Versión recursiva}
\paragraph{Eficiencia teórica}

A continuación se presenta el código que hemos usado para hacer el análisis:

\begin{lstlisting}[language=C, caption={Código de Hanoi}]
void Hanoi(int n, char from_rod, char to_rod,
            char aux_rod)
{
    if (n == 0) {
        return;
    }
    Hanoi(n - 1, from_rod, aux_rod, to_rod);
    cout << "Move disk " << n << " from rod " << from_rod
         << " to rod " << to_rod << endl;
    Hanoi(n - 1, aux_rod, to_rod, from_rod);
}
\end{lstlisting}

Tras analizar el código hemos llegado a la siguiente fórmula de recurrencia:

\[
H(n)=
\begin{cases}
0,  & \text{si } n = 0,\\[6pt]
2\cdot H(n-1), & \text{si } n > 0
\end{cases}
\]

Concluimos que en las dos llamadas recursivas de \textit{Hanoi}
se utiliza \textit{n - 1}, de donde sale $2\cdot H(n-1)$, y el caso base 
0 ocurre cuando hay 0 discos.

Procedemos a resolver la ecuación:

\begin{align*}
	x - 2 = 0 \\
	x = 2
\end{align*}

Por tanto la solución es $(x -2)$, con multiplicidad 1, y expresando la 
ecuación con coeficientes llegamos finalmente a:

\begin{equation*}
	c_{1}\cdot 2^{n}
\end{equation*}

De donde se deduce que Hanoi tiene una eficiencia de \textit{O}$(2^{n})$

\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\subsubsection{Versión iterativa usando una pila}

\paragraph{Eficiencia teórica}

A continuación se presenta el código que hemos usado para hacer el análisis:

\begin{lstlisting}[language=C, caption={Código de Hanoi Iterativo con pila}]
	void moveDisk(int a, int b)
	{
		if (!stacks[a].empty() && (stacks[b].empty() || stacks[a].top() < stacks[b].top()))
		{
			stacks[b].push(stacks[a].top());
			stacks[a].pop();
		}
	}
	 
	void Hanoi(int n)
	{
	 
		int src = 0, aux = 1, dest = 2;
		for (int i = n; i > 0; i--)
			stacks[src].push(i);
	 
		int totalMoves = (1 << n) - 1;
		if (n % 2 == 0)
			swap(aux, dest);
	 
		for (int i = 1; i <= totalMoves; i++)
		{
			if (i % 3 == 0)
				moveDisk(aux, dest);
			else if (i % 3 == 1)
				moveDisk(src, dest);
			else
				moveDisk(src, aux);
		}
	}
\end{lstlisting}

Tras analizar el código vemos que:

El primer bucle claramente tiene una eficiencia de \textit{O}(n) ya que vemos que comienza con $i=n$ (el número de discos)
y va decrementando hasta llegar a 0.\\

El segundo bucle recorre desde $i=1$ hasta llegar a la variable totalMoves que se obtiene con la función 
$(1 \ll n) - 1$ que equivale a $2^n - 1$ por tanto el segundo bucle tiene una eficiencia de \textit{O}($2^n$).\\

Por tanto, por la regla del máximo, al no estar los bucles anidados obtenemos que la eficiencia total de la función es \textit{O}($2^n$).\\

\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\subsubsection{Versión iterativa sin usar la pila}

\paragraph{Eficiencia teórica}

A continuación se presenta el código que hemos usado para hacer el análisis:

\begin{lstlisting}[language=C, caption={Código de Hanoi Iterativo sin pila}]
	void moveDisksBetweenTwoPoles(struct Stack *src, struct Stack *dest, char s, char d) {
		int pole1TopDisk = pop(src);
		int pole2TopDisk = pop(dest);
	
		if (pole1TopDisk == INT_MIN) {
			push(src, pole2TopDisk);
		} else if (pole2TopDisk == INT_MIN) {
			push(dest, pole1TopDisk);
		} else if (pole1TopDisk > pole2TopDisk) {
			push(src, pole1TopDisk);
			push(src, pole2TopDisk);
		} else {
			push(dest, pole2TopDisk);
			push(dest, pole1TopDisk);
		}
	}
	
	void tohIterative(int num_of_disks, struct Stack *src, struct Stack *aux, struct Stack *dest) {
		char s = 'S', d = 'D', a = 'A';
		if (num_of_disks % 2 == 0) swap(d, a);
	
		int total_num_of_moves = pow(2, num_of_disks) - 1;
		for (int i = num_of_disks; i >= 1; i--) push(src, i);
	
		for (int i = 1; i <= total_num_of_moves; i++) {
			if (i % 3 == 1) moveDisksBetweenTwoPoles(src, dest, s, d);
			else if (i % 3 == 2) moveDisksBetweenTwoPoles(src, aux, s, a);
			else moveDisksBetweenTwoPoles(aux, dest, a, d);
		}
	}
\end{lstlisting}

Tras analizar el código vemos que:

El primer bucle claramente tiene una eficiencia de \textit{O}(n) ya que vemos que comienza con $i=n$ (el número de discos)
y va decrementando hasta llegar a 1.\\

El segundo bucle recorre desde $i=1$ hasta llegar a la variable total\_num\_of\_moves que se obtiene con la función 
pow(2, num\_of\_disks) - 1 que equivale a $2^n - 1$ por tanto el segundo bucle tiene una eficiencia de \textit{O}($2^n$).\\

Por tanto, por la regla del máximo, al no estar los bucles anidados obtenemos que la eficiencia total de la función es \textit{O}($2^n$).\\

\paragraph{Eficiencia práctica}

A continuación mostramos las gráficas resultantes de ejecutar el algoritmo \textit{QuickSort} 
sobre tamaños empezando desde 100 hasta 1.000.000 con saltos de 31.000:

\section{Conclusión}
En conclusión, somos sudorosos.




\end{document}