\documentclass[a4paper,12pt]{article}

\input{preambulos.tex} % Todos los preámbulos

% =====================
% Índice
% =====================
\begin{document}
\input{portada.tex} % Archivo con la portada

% =====================
\section{Introducción}
% =====================
En esta práctica se desarrolla la resolución de tres problemas diferentes: 

\begin{itemize}
	\item Menor número
	\item Menor distancia
	\item Menor envolvente convexa
\end{itemize}

Lo haremos de dos maneras distintas, primero haremos una aproximación mediante algoritmos 
de fuerza bruta y después aplicaremos lo aprendido en clase, desarrollando soluciones basadas 
en divide y vencerás.


% =====================
\section{Objetivos}
% =====================
Los objetivos de esta práctica son los siguientes:
\begin{itemize}
	\item Comprender la técnica de Divide y Vencerás y sus ventajas.
	\item Comparar con la estrategia de fuerza bruta y analizar la complejidad.
	\item Implementar ambos enfoques (fuerza bruta y Divide y Vencerás) para cada problema.
	\item Experimentar con el umbral de la técnica de Divide y Vencerás.
\end{itemize}

% =====================
\section{El número más pequeño}
\label{sec:El número más pequeño}
% =====================
\subsection{Análisis de Fuerza Bruta}

Nuestra idea para desarrollar el algoritmo de fuerza bruta se basa en ir recorriendo el vector de puntos tantas veces como cifras tenga el número que busquemos, y en cada recorrido se busca el número más pequeño, se elimina y se procede a hacer lo mismo en la siguiente iteración.

El código es el siguiente:

\begin{lstlisting}[language=C, caption={Brute Force de \textbf{"El número más pequeño"}}]
	int getSmallestNumber(vector<int> v, int k){
		int smallestNumber = std::numeric_limits<int>::max();
		for (int i = 0; i < v.size()-1; ++i){
			string num;
			num.append(to_string(v[i]));
			for (int j = i+1; j-i <= k  && v.size()-1 - j >= k; ++j){
				num.append(to_string(v[j]));
			}
			if(stoi(num) < smallestNumber)
				smallestNumber = stoi(num);   
		}
	
		return smallestNumber;
	}	
	 \end{lstlisting}

Tras el análisis teórico comprobamos que este código tiene una eficiencia de $O(k\cdot n)$.
\subsection{Análisis de Divide y Vencerás}
Nuestra idea para desarrollar el algoritmo de Divide y Vencerás se basa en orderar el vector utilizando quickSort (para dividir y vencer) y una vez lo tenemos ordenado simplemente cogemos los k primeros números.

El código es el siguiente:

\begin{lstlisting}[language=C, caption={Divide y vencerás de \textbf{"El número más pequeño"}}]
void quicksort(vector<int> &v, int left, int right)
{
	if (left >= right)
		return;
	int pivot = v[right];
	int partitionIndex = left;
	for (int i = left; i < right; ++i)
	{
		if (v[i] < pivot)
		{
			swap(v[i], v[partitionIndex]);
			++partitionIndex;
		}
	}
	swap(v[partitionIndex], v[right]);
	quicksort(v, left, partitionIndex - 1);
	quicksort(v, partitionIndex + 1, right);
}

int getSmallestNumber(vector<int> v, int k)
{
	quicksort(v, 0, v.size() - 1);
	string result = "";
	for (int i = 0; i < k; ++i)
	{
		result += to_string(v[i]);
	}
	return stoi(result);
}	
	 \end{lstlisting}

Tras el análisis teórico comprobamos que este código tiene una eficiencia de $O(n\cdot \log (n))$

\subsection{Configuración de las Pruebas}
\begin{itemize}
	\item Descripción del entorno de ejecución (CPU, memoria, compilador, etc.).
	\item Conjunto de datos utilizados para las pruebas (tamaño, forma de generarlos).
\end{itemize}

\subsection{Tablas y Gráficos de Rendimiento}
Insertar aquí las tablas y/o gráficos que muestren los tiempos de ejecución,
uso de memoria, etc.

\subsection{Análisis de los Resultados}
Tras el analisis teórico y visualizar la gráfica comparativa, vemos que el algoritmo de Fuerza 
Bruta consigue resolver el problema de forma más eficiente que el algoritmo Divide y Vencerás. 
Esto se debe a que el primer algortimo depende de una constante k que consideramos siempre menor 
que n, y por tanto no afecta a la eficiencia. Mientras que en el segundo algoritmo podemos apreciar 
que quicksort tiene la eficiencia del peor caso, ya que al solo usar dígitos del 1 al 9, encontramos
en el vector una gran cantidad de números repetidos lo cual afecta gravemente a la eficiencia de este 
algortimo de ordenación.

\begin{itemize}
	\item Comparación cualitativa (efectividad, facilidad de implementación).
	\item Comparación cuantitativa (tiempos de ejecución, consumo de memoria).
	\item Conclusiones sobre el umbral experimental.
\end{itemize}



% =====================
\section{El par de puntos más cercano}
% =====================
\subsection{Análisis de Fuerza Bruta}
Nuestra idea para desarrollar el algoritmo de fuerza bruta se basa en un doble bucle for el cual hace todas las distancias de todos los puntos con todos, hasta encontrar la mínima distancia. 

El código es el siguiente:

\begin{lstlisting}[language=C, caption={Brute Force de \textbf{"El par de puntos más cercano"}}]
struct Point {
	double x, y;
};

double dist(Point p1, Point p2) {
	return sqrt( (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y) );
}


double bruteForce(const vector<Point>& P, int l, int r) {
	double minDist = DBL_MAX;
	for (int i = l; i <= r; i++) {
		for (int j = i+1; j <= r; j++) {
			double d = dist(P[i], P[j]);
			if (d < minDist) {
				minDist = d;
			}
		}
	}
	return minDist;
}
\end{lstlisting}

Tras el análisis teórico comprobamos que este código tiene una eficiencia de $O(n^2)$.

\subsection{Análisis de Divide y Vencerás}
Nuestra idea para desarrollar el algoritmo de Divide y Vencerás se basa en ir haciendo divisiones
de un array de puntos previamente ordenados por la coordenada x de los puntos (de derecha a izquierda).
Tras esto, vamos haciendo divisiones partiendo el vector por la mitad recursivamente hasta quedarnos con 3 
puntos o menos en una franja, donde se resolverá el problema usando fuerza bruta. Así obtenemos la mínima distancia 
en una franja, tras esto nos quedamos con la mínima distancia entre la franja de la izquierda y la derecha, y la 
usaremos para estudiar la mínima distancia entre una franja intermedia de tamaño la mínima distancia, creamos esta franja 
con los puntos que estan a una distancia menor de la menor distancia previamente calculada respecto del punto central.
Una vez construido el strip comparamos los puntos con respecto a su coordenada y (esta comparación se hace con un 
número comnstante de puntos al reducirlos con la distancia mínima), buscando que sea menor que la menor distancia previa,
obtenemos así la mínima distancia entre la franja izquierda, derecha y central. Resolviendo recursivamente obtenemos 
la mínima distancia en un conjunto de puntos.

El código es el siguiente:

\begin{lstlisting}[language=C, caption={Divide y vencerás de \textbf{"El par de puntos más cercano"}}]
	void swap(Point* a, Point* b) {
		Point t = *a;
		*a = *b;
		*b = t;
	}
	
	int partition(vector<Point>& arr, int low, int high) {
		double pivot = arr[high].x;
		int i = (low - 1);
	
		for (int j = low; j <= high - 1; j++) {
			if (arr[j].x < pivot) {
				i++;
				swap(&arr[i], &arr[j]);
			}
		}
		swap(&arr[i + 1], &arr[high]);
		return (i + 1);
	}
	
	void quickSort(vector<Point>& arr, int low, int high) {
		if (low < high) {
			int pi = partition(arr, low, high);
	
			quickSort(arr, low, pi - 1);
			quickSort(arr, pi + 1, high);
		}
	}
	
	void sort_by_x(vector<Point>& points) {
		quickSort(points, 0, points.size() - 1);
	}
	
	double bruteForce(const vector<Point>& P, int l, int r) {
		double minDist = DBL_MAX;
		for (int i = l; i <= r; i++) {
			for (int j = i+1; j <= r; j++) {
				double d = dist(P[i], P[j]);
				if (d < minDist) {
					minDist = d;
				}
			}
		}
		return minDist;
	}
	
	
	double closestUtil(vector<Point> &PX, int l, int r) {
		// Si el subrango es peque, fuerza bruta
		if (r - l <= 3) {
			return bruteForce(PX, l, r);
		}
	
		int mid = (l + r) / 2;
		double midX = PX[mid].x;
	
		// bestPair se va actualizando; 
		// para tener la minima distancia, llamo recursivamente a izq y der
		double dl = closestUtil(PX, l, mid);
		double dr = closestUtil(PX, mid+1, r);
	
		double d = dl < dr ? dl : dr;
		// Construir el strip (puntos que quedan en [midX - d, midX + d])
		vector<Point> strip;
		strip.reserve(r - l + 1);
		for (int i = l; i <= r; i++) {
			if (fabs(PX[i].x - midX) < d) {
				strip.push_back(PX[i]);
			}
		}
		// Ordenar la franja por Y
		sort(strip.begin(), strip.end(), [](auto &a, auto &b){
			return a.y < b.y;
		});
	
		// Revisar cada punto del strip con sus siguientes
		// mientras la diferencia en Y sea < d
		for (int i = 0; i < (int)strip.size(); i++) {
			for (int j = i+1; j < (int)strip.size() && (strip[j].y - strip[i].y) < d; j++) {
				double distStrip = dist(strip[i], strip[j]);
				if (distStrip < d) {
					d = distStrip;
				}
			}
		}
	
		return d;
	}
\end{lstlisting}

Para el análisis teórico de este algoritmo debemos estudiar la ecuación de recurrencia: $T(n) = 2T(\frac{n}{2}) + O(n)$.
Esta ecuación se obtiene de que una llamada a la función de tamaño n hará dos llamadas recursivas con cada mitad de los puntos (izquierda y derecha),
O(n) se obtiene de calcular los puntos en el strip central, que auqnue pueda parecer $O(n²)$, cada punto del strip solo 
se compara con un número constante de puntos, al habernos quedado previamnete con una cantidad de puntos pequeñas dentro de un rango.
Cuando el tamaño es menor o igual que 3 (caso base), donde aplicamos 
fuerza bruta, al ser un tamaño tan pequeño, no afectará a la eficiencia.


Tras resolver la recurrencia comprobamos que este código tiene una eficiencia de $O(n\cdot \log (n))$.

\subsection{Detalles de Implementación}

\subsection{Configuración de las Pruebas}
\begin{itemize}
	\item Descripción del entorno de ejecución (CPU, memoria, compilador, etc.).
	\item Conjunto de datos utilizados para las pruebas (tamaño, forma de generarlos).
\end{itemize}

\subsection{Tablas y Gráficos de Rendimiento}
Insertar aquí las tablas y/o gráficos que muestren los tiempos de ejecución,
uso de memoria, etc.

\subsection{Análisis de los Resultados}
Como se esperaba tras el análisis teórico, en las gráficas podemos observar que el algoritmo Divide y Vencerás 
tiene una mayor eficiencia que el de Fuerza Bruta, también podemos observar la clara forma parábolica del algoritmo
Fuerza Bruta como habiamos previsto. También se puede observar la región a partir del cual el primer algortimo, comienza 
a tener tiempos de ejecución más bajos que el segundo.
\begin{itemize}
	\item Comparación cualitativa (efectividad, facilidad de implementación).
	\item Comparación cuantitativa (tiempos de ejecución, consumo de memoria).
	\item Conclusiones sobre el umbral experimental.
\end{itemize}


% =====================
\section{La envolvente convexa}
% =====================
\subsection{Análisis de Fuerza Bruta}

Nuestra idea para desarrollar el algoritmo de fuerza bruta se basa en empezar seleccionando el punto más a la izquierda, 
el cual sabemos que siempre va a estar en la envolvente convexa, seguidamente seleccionas otro punto y compruebas si 
la recta que une los dos puntos deja el resto de puntos a la izquierda, una vez encuentras ese punto, es nuevo punto 
actúa como el primero que seleccionaste, y haces esto hasta que encuentres todos los puntos pertenecientes a la envolvente convexa.

El código es el siguiente:

\begin{lstlisting}[language=C, caption={Brute Force de \textbf{"La envolvente convexa"}}]
	// Estructura para representar un punto
	struct Point {
		float x, y;
	};
	
	typedef pair<int, int> ParPuntos;
	
	// Funcion que calcula el convex hull por fuerza bruta
	set<ParPuntos> convexHullBruteForce(const vector<Point>& points) {
		int n = points.size();
		set<ParPuntos> hull;
		
		// Recorremos cada par de puntos
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				int left = 0, right = 0;
				
				// Verificamos la posicion de cada otro punto respecto a la linea formada por points[i] y points[j]
				for (int k = 0; k < n; k++) {
					if (k == i || k == j)
						continue;
						
					float position = (points[j].x - points[i].x) * (points[k].y - points[i].y) -
								   (points[j].y - points[i].y) * (points[k].x - points[i].x);
					
					if (position > 0)
						left++;
					else if (position < 0)
						right++;
				}
				
				// Si todos los puntos se encuentran de un mismo lado (o son colineales), se adjuntan los puntos de la arista
				if (left == 0 || right == 0) {
					hull.insert({points[i].x, points[i].y});
					hull.insert({points[j].x, points[j].y});
				}
			}
		}
		
		return hull;
	}
\end{lstlisting}

Tras el análisis teórico comprobamos que este código tiene una eficiencia de $O(n^3)$

\subsection{Análisis de Divide y Vencerás}
Nuestra idea para desarrollar el algoritmo de Divide y Vencerás se basa en ir diviendo los puntos del plano, previamente ordenados 
de derecha a izquierda, en dos partes (izquierda y derecha) hasta llegar a un tamaño pequeño donde se calculen las envolventes convexas,
tanto de izquierda como de derecha que se juntarán usando la función merge. Esta función comienza buscando de entre los puntos de la envolvente de la derecha 
el punto más a la izquierda, actuando analogamente con los de la izquierda, tras esto buscamos la tangente superior que cuyos puntos 
formarán parte de la envolvente. Para ello, vamos buscando con el punto más a la derecha de la izquierda fijo, y rotando el punto más a la 
izquierda de los derecha, ahcia la derecha hasta encontrar uno que deje el resto de puntos a la derecha, una vez lo encontramos fijamos 
ese punto y rotamos hacia la izquierda los puntos de la izquierda hasta encontrar uno que deje todos los puntos de la izquierda a la izquierda.
Repetimos para la tangente inferior rotando en sentido contrario, finalizamos guardando todoos los puntos resultantes en el vector a devolver.s

código

Para el análisis teórico de este algoritmo debemos estudiar la ecuación de recurrencia: $T(n) = 2T(\frac{n}{2}) + O(n)$.
Esta ecuación se obtiene de que una llamada a la función de tamaño n hará dos llamadas recursivas con cada mitad de los puntos (izquierda y derecha),
O(n) se obtiene de la llamada a la función merger que junta las dos envolventes con una eficiencia de O(n), ya que
hay se recorren varios bucles de la mitad del tamaño en cada iteración ($\frac{n}{2}$) obviando la constante obtenemos O(n).
El caso base usa la fuerza bruta en un conjunto de 5 puntos, su eficiencia es presecindible.

Tras resolver la recurrencia comprobamos que este código tiene una eficiencia de $O(n\cdot \log (n))$.

\subsection{Detalles de Implementación}

\subsection{Configuración de las Pruebas}
\begin{itemize}
	\item Descripción del entorno de ejecución (CPU, memoria, compilador, etc.).
	\item Conjunto de datos utilizados para las pruebas (tamaño, forma de generarlos).
\end{itemize}

\subsection{Tablas y Gráficos de Rendimiento}
Insertar aquí las tablas y/o gráficos que muestren los tiempos de ejecución,
uso de memoria, etc.

\subsection{Análisis de los Resultados}
Como se esperaba tras el análisis teórico, en las gráficas podemos observar que el algoritmo Divide y Vencerás 
tiene una mayor eficiencia que el de Fuerza Bruta, también podemos observar la clara forma cúbica del algoritmo
Fuerza Bruta como habiamos previsto. También se puede observar la región a partir del cual el primer algortimo, comienza 
a tener tiempos de ejecución más bajos que el segundo.
\begin{itemize}
	\item Comparación cualitativa (efectividad, facilidad de implementación).
	\item Comparación cuantitativa (tiempos de ejecución, consumo de memoria).
	\item Conclusiones sobre el umbral experimental.
\end{itemize}

En esta sección se describen los diferentes problemas que se abordarán.

% =====================
\section{Conclusiones}
% =====================
Tras esta práctica hemos descubierto que la estrategia de desarrollo de algoritmos Divide y Vencerás 
es útil en un amplio repertorio de casos pero esto no quiere decir que siempre sea mejor que un algoritmo 
fuerza bruta, esto lo podemos comprobar en \ref{sec:El número más pequeño}. Aún así en la gran mayoría de casos aplicar Divide y Vencerás 
supone una mejoría en la eficiencia del código.

\end{document}

